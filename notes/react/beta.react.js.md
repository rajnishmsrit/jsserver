# Beta Site
## Learn Section
-   Describing the UI
    -   nextjs renders partial html and rest react takes over by default
    -   use as little react possible
    -   write a function to create jsx to html
    -   What does react fragment actually do?
    -   Why do multiple JSX tags need to be wrapped?
        -   JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment.
    -  Quotes for strings "", '', { for scripts }
    -   `{{ Double curlies for objects and css }}`
    -   `<ul style="background-color: black">` would be written as `<ul style={{ backgroundColor: 'black' }}>`
    -   Don’t miss the pair of { and } curlies inside of ( and ) when declaring props:   
    -   Passing Props
        -    Props are not always static
        -   You can’t change props. When you need interactivity, you’ll need to set state
        -   {children} prop
        - Props are read-only snapshots in time: every render receives a new version of props.
    -   Conditional Rendering
        -   Don’t put numbers on the left side of &&.
        -   In JSX, `{cond ? <A /> : <B />}` means “if cond, render `<A />`, otherwise `<B />`”.
        -   In JSX, `{cond && <A />}` means “if cond, render `<A />`, otherwise nothing”.
    -   Rendering Lists
        -   key can be built using database values or crypto.randomUUIID()
        -   Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays.
        -   Keys must not change or that defeats their purpose! Don’t generate them while rendering.
        -   do not generate keys on the fly, e.g. with key={Math.random()}
    -   Keep Components Pure
        -   In React there are three kinds of inputs that you can read while rendering: props, state, and context. You should always treat these inputs as read-only.
        -   React offers a “Strict Mode” in which it calls each component’s function twice during development.
        -   You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen, “set” state instead of mutating preexisting objects.
        -   Strive to express your component’s logic in the JSX you return. When you need to “change things”, you’ll usually want to do it in an event handler. As a last resort, you can useEffect.
        -   Writing pure functions takes a bit of practice, but it unlocks the power of React’s paradigm.
        -   Pure functions can be run on server and you need to not worry since the return are always same.
        -   Rendering can happen at any time, so components should not depend on each others’ rendering sequence.
-   Adding Interactivity
    -   If copying objects in code gets tedious, you can use a library like Immer to reduce repetitive code:
    -   State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy.
        -   Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array:
    -   Responding to Events
        -   By convention, it is common to name event handlers as handle followed by the event name. You’ll often see onClick={handleClick}, onMouseEnter={handleMouseEnter}, and so on.
        -   Functions passed to event handlers must be passed, not called.
        -   If you want to define your event handler inline, wrap it in an anonymous function like so: `<button onClick={() => alert('You clicked me!')}>`
        -   By convention, event handler props should start with on, followed by a capital letter.
        -   When does the event propagation stop? at body? head?
        -   Capture events are useful for code like routers or analytics, but you probably won’t use them in app code.
        -   You can handle events by passing a function as a prop to an element like <button>.
        -   Event handlers must be passed, not called! onClick={handleClick}, not onClick={handleClick()}.
        -   You can define an event handler function separately or inline.
        -   Event handlers are defined inside a component, so they can access props.
        -   You can declare an event handler in a parent and pass it as a prop to a child.
        -   You can define your own event handler props with application-specific names.
        -   Events propagate upwards. Call e.stopPropagation() on the first argument to prevent that.
        -   Events may have unwanted default browser behavior. Call e.preventDefault() to prevent that.
        -   Explicitly calling an event handler prop from a child handler is a good alternative to propagation.
    -   State: A Component's Memory
        -   Hooks are special functions that are only available while React is rendering
        -   Use a state variable when a component needs to “remember” some information between renders.
        -   State variables are declared by calling the useState Hook.
        -   Hooks are special functions that start with use. They let you “hook into” React features like state.
        -   Hooks might remind you of imports: they need to be called unconditionally. Calling Hooks, including useState, is only valid at the top level of a component or another Hook.
        -   The useState Hook returns a pair of values: the current state and the function to update it.
        -   You can have more than one state variable. Internally, React matches them up by their order.
        -   State is private to the component. If you render it in two places, each copy gets its own state.
    -   Render and Commit
        -   After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting” to avoid confusion in the rest of these docs.
        -   Any screen update in a React app happens in three steps:
            -   Trigger
            -   Render
            -   Commit
        -   You can use Strict Mode to find mistakes in your components
        -   React does not touch the DOM if the rendering result is the same as last time
    -   State as a Snapshot
        -   Setting state requests a new render.
        -   React stores state outside of your component, as if on a shelf.
        -   When you call useState, React gives you a snapshot of the state for that render.
        -   Variables and event handlers don’t “survive” re-renders. Every render has its own event handlers.
        -   Every render (and functions inside it) will always “see” the snapshot of the state that React gave to that render.
        -   You can mentally substitute state in event handlers, similarly to how you think about the rendered JSX.
        -   Event handlers created in the past have the state values from the render in which they were created.